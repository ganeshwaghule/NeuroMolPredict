# -*- coding: utf-8 -*-
"""Target Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZGexNL9sExx00r9Nc1q8roOYLx9HxOTE

##Install Required Packages
"""

!pip install --upgrade chembl_webresource_client
!pip install reportlab
!pip install pandas
!pip install scikit-learn
!pip install joblib
!pip install requests

#Set google drive
from google.colab import auth
auth.authenticate_user()

from google.colab import drive
drive.mount('/content/gdrive')

"""#Target Predictiom for Molecule"""

#Final Code for Target Prediction

import pandas as pd
import requests
import joblib
import numpy as np
from IPython.display import HTML, display
import ipywidgets as widgets
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle
from reportlab.lib.units import inch
import warnings

# Suppress warnings related to feature names
warnings.filterwarnings('ignore', category=UserWarning)

# Mock function to simulate preprocessing new data
def preprocess_new_data(target_data):
    # Replace with actual preprocessing steps used in training
    processed_data = {'feature1': np.random.random(), 'feature2': np.random.random()}
    return processed_data

# Function to calculate probability using a pre-trained model
def calculate_probability_with_model(model, compound_id, target_data):
    processed_data = preprocess_new_data(target_data)
    probability = model.predict_proba([list(processed_data.values())])[0][1]
    return round(probability * 100, 2)

# Load the pre-trained model
model_filename = '/content/chembl_bioactivity_model.pkl'
model = joblib.load(model_filename)

# Function to fetch targets for a given SMILES string using the ChEMBL API
def fetch_targets(smiles, similarity_threshold=50):
    base_url = 'https://www.ebi.ac.uk/chembl/api/data'
    headers = {'Accept': 'application/json'}

    similarity_search_url = f'{base_url}/similarity/{smiles}/{similarity_threshold}'
    similarity_response = requests.get(similarity_search_url, headers=headers)
    if not similarity_response.ok:
        return pd.DataFrame()

    similar_molecules = similarity_response.json()['molecules']
    if not similar_molecules:
        return pd.DataFrame()

    targets = []
    for molecule in similar_molecules:
        chembl_id = molecule['molecule_chembl_id']
        activity_search_url = f'{base_url}/activity'
        activity_params = {'molecule_chembl_id': chembl_id, 'limit': 30}
        activity_response = requests.get(activity_search_url, headers=headers, params=activity_params)
        if not activity_response.ok:
            continue

        activities = activity_response.json()['activities']
        for activity in activities:
            target_chembl_id = activity.get('target_chembl_id')
            target_search_url = f'{base_url}/target/{target_chembl_id}'
            target_response = requests.get(target_search_url, headers=headers)
            if target_response.ok:
                target_data = target_response.json()
                target_name = target_data['pref_name']
                # Filter out irrelevant targets
                if target_name not in ["Unchecked", "No relevant target", "Caco-2", "Plasma", "ADMET"]:
                    probability = calculate_probability_with_model(model, chembl_id, target_data)
                    targets.append({
                        'ChEMBL ID': target_chembl_id,
                        'Target name': target_name,
                        'Protein Target Classification': target_data['target_type'],
                        'Uniprot ID': next((component['accession'] for component in target_data['target_components']), ''),
                        'Probability (%)': probability,
                    })

    return pd.DataFrame(targets)

# Function to create PDF from DataFrame
def create_pdf(df, filename):
    doc = SimpleDocTemplate(filename, pagesize=letter)
    elements = []
    data = [df.columns.to_list()] + df.values.tolist()
    t = Table(data, colWidths=[1.5*inch, 2.5*inch, 2*inch, 1.5*inch, 1*inch], repeatRows=1)
    t.setStyle(TableStyle([('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                           ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                           ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                           ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                           ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                           ('BACKGROUND', (0, 1), (-1, -1), colors.beige)]))
    elements.append(t)
    doc.build(elements)

# Function to handle button click and download PDF
def download_pdf(b):
    create_pdf(df_targets, 'output.pdf')
    print("PDF file created. Check your notebook's file directory.")

# Prompt the user to enter a SMILES string and display results
smiles_string = input("Please enter the SMILES string of the compound: ")
df_targets = fetch_targets(smiles_string)
if df_targets.empty:
    print(f"No targets found for the compound with SMILES: {smiles_string}")
else:
    display(HTML(df_targets.to_html(escape=False, index=False)))
    button = widgets.Button(description="Download PDF")
    button.on_click(download_pdf)
    display(button)